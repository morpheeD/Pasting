import click
import pandas as pd
import re
from packaging import version
from pathlib import Path

def extract_template_version(template):
    """Extrait la version après 'V-' dans un nom de template"""
    if not isinstance(template, str):
        return None
    template = template.strip()
    match = re.search(r'V-([^-]*)$', template)
    return match.group(1) if match else None

def validate_template_row(row, vmaas_version):
    """Valide une ligne du DataFrame selon les règles de version"""
    template = row.get('vm_template', '').strip()
    vm_name = row.get('vm_name', 'N/A')

    if not template:
        return False, f"Template vide pour la VM '{vm_name}'"

    template_version = extract_template_version(template)
    if template_version is None:
        return False, f"Format invalide pour '{template}' (doit contenir 'V-' suivi d'une version ou 'ISIOPERATION')"

    # Cas spécial pour ISIOPERATION
    if template_version == "ISIOPERATION":
        # Vérification que vMaas est ≥2.0.0 si template est ISIOPERATION
        if version.parse(vmaas_version) < version.parse("2.0.0"):
            return False, f"Template 'ISIOPERATION' nécessite vMaas ≥2.0.0 (version actuelle: {vmaas_version})"
        return True, None

    # Vérification des versions numériques
    try:
        template_ver = version.parse(template_version)
        vmaas_ver = version.parse(vmaas_version)

        # Si template ≥2.0, vMaas doit être ≥2.0.0
        if template_ver >= version.parse("2.0"):
            if vmaas_ver < version.parse("2.0.0"):
                return False, f"Template version {template_version} nécessite vMaas ≥2.0.0 (version actuelle: {vmaas_version})"

        # Vérification originale pour les versions <2.0
        if vmaas_ver >= version.parse("2.0.0"):
            if template_ver < version.parse("2.0"):
                return False, f"Version '{template_version}' < 2.0 pour '{template}'"

    except version.InvalidVersion:
        return False, f"Version invalide '{template_version}' dans '{template}'"

    return True, None

@click.command()
@click.option('--csv-file', type=click.Path(exists=True, dir_okay=False),
              required=True, help='Chemin vers le fichier CSV')
@click.option('--vmaas-version', required=True,
              help='Version de vMaas (ex: 2.0.0)')
@click.option('--chunk-size', default=1000, type=int,
              help='Taille des chunks pour le traitement (défaut: 1000)')
def validate_csv(csv_file, vmaas_version, chunk_size):
    """Valide le fichier CSV selon les règles de vMaas"""
    try:
        # Vérification du fichier
        file_path = Path(csv_file)
        if not file_path.suffix.lower() == '.csv':
            raise ValueError("Le fichier doit être un CSV")

        # Vérification des colonnes requises
        test_df = pd.read_csv(file_path, delimiter=';', nrows=1)
        if 'vm_template' not in test_df.columns:
            raise ValueError("Le fichier CSV doit contenir une colonne 'vm_template'")

        # Lecture par chunks pour les gros fichiers
        chunks = pd.read_csv(
            file_path,
            delimiter=';',
            chunksize=chunk_size,
            dtype=str,
            encoding='utf-8-sig'
        )

        errors = []
        total_rows = 0

        for chunk in chunks:
            for _, row in chunk.iterrows():
                total_rows += 1
                is_valid, error_msg = validate_template_row(row, vmaas_version)
                if not is_valid:
                    errors.append(f"Ligne {total_rows} (VM: {row.get('vm_name', 'N/A')}): {error_msg}")

        # Affichage des résultats
        if errors:
            click.echo(f"\n❌ {len(errors)} erreurs trouvées sur {total_rows} lignes:")
            for error in errors[:20]:  # Affiche max 20 erreurs
                click.echo(f"- {error}")
            if len(errors) > 20:
                click.echo(f"... et {len(errors)-20} autres erreurs")
            exit(1)
        else:
            click.echo(f"\n✅ Validation réussie: {total_rows} lignes valides")

    except Exception as e:
        click.echo(f"\n⚠️ Erreur: {str(e)}", err=True)
        exit(1)

if __name__ == '__main__':
    validate_csv()
