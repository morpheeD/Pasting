import pandas as pd
import json
from pathlib import Path
import click

def load_csv(path: Path, sep: str = ";") -> pd.DataFrame:
    """Charge un fichier CSV en DataFrame."""
    return pd.read_csv(path, sep=sep, dtype=str)

def load_json(path: Path) -> pd.DataFrame:
    """Charge un fichier JSON en DataFrame."""
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
    return pd.DataFrame(data).astype(str)

def sync(
    df_csv: pd.DataFrame,
    df_json: pd.DataFrame,
    keys: list[str]
) -> tuple[pd.DataFrame, pd.DataFrame]:
    """
    Synchronise les données entre le CSV et le JSON.
    Met à jour les valeurs du CSV avec celles du JSON quand elles diffèrent.
    """
    # Colonnes à comparer (toutes sauf les clés)
    compare_cols = [c for c in df_csv.columns if c not in keys]

    # Fusion des données
    merged = df_csv.merge(
        df_json[keys + compare_cols],
        on=keys,
        how="left",
        suffixes=("", "_json")
    )

    # Préparation du rapport des changements
    changes = []

    # Comparaison et mise à jour
    for col in compare_cols:
        col_json = f"{col}_json"
        # Trouver les lignes où JSON a une valeur différente et non vide
        mask = (merged[col_json].notna()) & (merged[col] != merged[col_json])

        # Enregistrer les changements
        for idx in merged[mask].index:
            change = {**{k: merged.at[idx, k] for k in keys},
                      "column": col,
                      "old": merged.at[idx, col],
                      "new": merged.at[idx, col_json]}
            changes.append(change)

        # Mettre à jour les valeurs du CSV avec celles du JSON
        merged[col] = merged[col_json].combine_first(merged[col])
        merged.drop(columns=[col_json], inplace=True)

    # Créer le DataFrame de rapport
    df_report = pd.DataFrame(changes)

    # Conserver l'ordre original des colonnes
    df_corrected = merged[df_csv.columns]

    return df_corrected, df_report

@click.command()
@click.option('--csv', type=click.Path(exists=True, path_type=Path), required=True,
              help='Chemin vers le fichier CSV à mettre à jour')
@click.option('--json', type=click.Path(exists=True, path_type=Path), required=True,
              help='Chemin vers le fichier JSON contenant les mises à jour')
@click.option('--keys', multiple=True, default=['vm_name'],
              help='Colonnes clés pour la synchronisation (par défaut: vm_name)')
@click.option('--out', type=click.Path(path_type=Path), default=Path('corrected.csv'),
              help='Fichier CSV de sortie corrigé (défaut: corrected.csv)')
@click.option('--report', type=click.Path(path_type=Path), default=Path('changes_report.csv'),
              help='Fichier CSV de rapport des modifications (défaut: changes_report.csv)')
def main(csv, json, keys, out, report):
    """Synchronise un fichier CSV avec les données d'un fichier JSON."""
    try:
        click.echo("Chargement des fichiers...")
        df_csv = load_csv(csv)
        df_json = load_json(json)

        click.echo("Synchronisation en cours...")
        df_corr, df_rep = sync(df_csv, df_json, list(keys))

        click.echo("Sauvegarde des résultats...")
        df_corr.to_csv(out, sep=";", index=False, encoding="utf-8")
        df_rep.to_csv(report, index=False, encoding="utf-8")

        click.echo(f"✅ Fichier corrigé enregistré: {out}")
        click.echo(f"✅ Rapport des modifications enregistré: {report}")
    except Exception as e:
        click.echo(f"❌ Erreur: {str(e)}", err=True)
        raise click.Abort()

if __name__ == "__main__":
    main()
