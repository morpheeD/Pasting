import pandas as pd
import json
from pathlib import Path
import click
from typing import List, Dict, Any

def load_csv_header(path: Path, sep: str = ";") -> List[str]:
    """Charge uniquement l'en-tête d'un fichier CSV."""
    with open(path, 'r', encoding='utf-8') as f:
        return f.readline().strip().split(sep)

def parse_terraform_state(state_path: Path) -> Dict[str, Any]:
    """Parse correctement un fichier de state Terraform JSON."""
    with open(state_path, 'r', encoding='utf-8') as f:
        return json.load(f)

def extract_resources_from_state(state: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Extrait les ressources d'un state Terraform au format v3 ou v4 (values.root_module + child_modules).
    Chaque ressource devient un dict plat avec ses attributs et métadonnées (id, type, name, etc.).
    """
    resources: List[Dict[str, Any]] = []

    def walk_module(module: Dict[str, Any], module_addr: str = ""):
        # resources dans root_module ou child_modules
        for res in module.get("resources", []):
            # nouvelle structure v4 -> "values", ancienne v3 -> "instances"[0]["attributes"]
            if "values" in res:
                attrs = res["values"]
                deps  = res.get("depends_on", [])
            else:
                inst  = res.get("instances", [{}])[0]
                attrs = inst.get("attributes", {})
                deps  = inst.get("dependencies", [])
            entry = {
                "address" : res.get("address", ""),
                "id"       : attrs.get("id", "") or res.get("id", ""),
                "type"     : res.get("type", ""),
                "name"     : res.get("name", ""),
                "module"   : module_addr,
                "provider" : res.get("provider_name", res.get("provider", "")),
                "mode"     : res.get("mode", ""),
                **attrs
            }
            if deps:
                entry["dependencies"] = ",".join(deps)
            resources.append(entry)

        # descendre dans les modules enfants (v4)
        for child in module.get("child_modules", []):
            child_addr = child.get("address", module_addr)
            walk_module(child, child_addr)

    # choix du schéma : v4 "values" vs v3 "resources"
    if "values" in state:
        root = state["values"].get("root_module", {})
        walk_module(root, module_addr="")
    else:
        # ancien schéma terraform <= 0.12
        dummy = {"resources": state.get("resources", [])}
        walk_module(dummy, module_addr="")

    return resources

def build_dataframe(state_path: Path, csv_header: List[str]) -> pd.DataFrame:
    """Construit un DataFrame à partir du state Terraform adapté au nouveau schéma JSON."""
    state     = parse_terraform_state(state_path)
    resources = extract_resources_from_state(state)

    if not resources:
        return pd.DataFrame(columns=csv_header)

    df = pd.DataFrame(resources)

    # ne garder que les colonnes de l'en-tête CSV
    cols_ok = [c for c in csv_header if c in df.columns]
    df      = df[cols_ok]

    # ajouter les colonnes manquantes
    for c in csv_header:
        if c not in df.columns:
            df[c] = ""

    # réordonner selon l'en-tête
    return df[csv_header]

@click.command()
@click.option(
    '--csv-header',
    type=click.Path(exists=True, dir_okay=False, path_type=Path),
    required=True,
    help="Fichier CSV dont on veut conserver l'en-tête"
)
@click.option(
    '--terraform-state',
    type=click.Path(exists=True, dir_okay=False, path_type=Path),
    required=True,
    help='Fichier de state Terraform au format JSON (v3 ou v4)'
)
@click.option(
    '--output',
    type=click.Path(dir_okay=False, path_type=Path),
    default=Path('terraform_resources.csv'),
    help='Fichier CSV de sortie'
)
@click.option('--sep', default=';', help='Séparateur CSV')
def main(csv_header: Path, terraform_state: Path, output: Path, sep: str):
    """Génère un CSV à partir d'un state Terraform v4 (values.root_module) en conservant l'en-tête du CSV."""
    try:
        click.echo("Chargement de l'en-tête du CSV...")
        header = load_csv_header(csv_header, sep)

        click.echo("Traitement du state Terraform...")
        df = build_dataframe(terraform_state, header)

        click.echo(f"Écriture du fichier de sortie {output}...")
        df.to_csv(output, sep=sep, index=False, encoding='utf-8')

        click.echo(f"✅ Fichier généré avec succès: {output}")
        click.echo(f"Nombre de ressources traitées: {len(df)}")
        click.echo(f"Colonnes incluses: {', '.join(header)}")

    except json.JSONDecodeError:
        click.echo(
            "❌ Erreur: Le fichier de state Terraform n'est pas un JSON valide",
            err=True
        )
        raise click.Abort()
    except Exception as e:
        click.echo(f"❌ Erreur: {str(e)}", err=True)
        raise click.Abort()

if __name__ == "__main__":
    main()
