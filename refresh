import pandas as pd
import json
from pathlib import Path
import click
from typing import List, Dict, Any

def load_csv_header(path: Path, sep: str = ";") -> List[str]:
    """Charge l'en-tête du CSV."""
    with open(path, 'r', encoding='utf-8') as f:
        return f.readline().strip().split(sep)

def extract_tags(state: Dict[str, Any]) -> Dict[str, Dict[str, str]]:
    """Extrait tous les tags du state Terraform."""
    tags = {}
    for resource in state.get('resources', []):
        if resource.get('type') == 'vsphere_tag':
            if resource.get('instances'):
                tag_attrs = resource['instances'][0]['attributes']
                tag_id = tag_attrs.get('id')
                if tag_id:
                    # Extraire le nom de la catégorie depuis category_id
                    category_id = tag_attrs.get('category_id', '')
                    category_name = category_id.split(':')[-2] if category_id else ''
                    tags[tag_id] = {
                        'name': tag_attrs.get('name', ''),
                        'category': category_name,
                        'description': tag_attrs.get('description', '')
                    }
    return tags

def extract_vms_with_tags(state: Dict[str, Any], tags: Dict[str, Dict[str, str]]) -> List[Dict[str, Any]]:
    """Extrait les VMs avec leurs tags associés."""
    vms = []

    # Mapping des catégories de tags aux noms de colonnes
    tag_mapping = {
        'workload': 'workload',
        'env': 'env',
        'confidentiality': 'confidentiality_tag',
        'integrity': 'integrity_tag',
        'availability': 'availability_tag',
        'BackupPolicy': 'backup_policy_tag',
        'managedby': 'managedby_tag',
        'business_service': 'business_service_tag',
        'technical_service': 'technical_service_tag',
        'component': 'component_tag',
        'security_zone': 'security_zone_tag',
        'owner': 'owner_tag',
        'site': 'site',
        'usage': 'usage',
        'appli': 'appli'
    }

    for resource in state.get('resources', []):
        if resource.get('type') == 'vsphere_virtual_machine':
            if not resource.get('instances'):
                continue

            attrs = resource['instances'][0]['attributes']
            vm_data = {
                'vm_name': attrs.get('name', ''),
                'num_cpus': attrs.get('num_cpus', ''),
                'workload': '',
                'env': '',
                'memory': attrs.get('memory', ''),
                'vm_dns': '',
                'vm_domain': attrs.get('domain', ''),
                'disk_1_taille': '',
                'disk_1_nom': '',
                'disk_2_taille': '',
                'disk_2_nom': '',
                'disk_3_taille': '',
                'disk_3_nom': '',
                'site': '',
                'usage': '',
                'appli': '',
                'network': '',
                'path_folder': attrs.get('folder', ''),
                'vm_ressource_pool': attrs.get('resource_pool_id', ''),
                'vm_template': '',
                'confidentiality_tag': '',
                'integrity_tag': '',
                'availability_tag': '',
                'backup_policy_tag': '',
                'managedby_tag': '',
                'business_service_tag': '',
                'technical_service_tag': '',
                'component_tag': '',
                'security_zone_tag': '',
                'owner_tag': '',
                'env_tag': ''
            }

            # Gestion des disques
            disks = attrs.get('disk', [])
            if isinstance(disks, dict):
                disks = [disks]

            for i, disk in enumerate(disks[:3], 1):
                if isinstance(disk, dict):
                    vm_data[f'disk_{i}_taille'] = disk.get('size', '')
                    vm_data[f'disk_{i}_nom'] = disk.get('label', '')

            # Gestion des interfaces réseau
            network_interfaces = attrs.get('network_interface', [])
            if isinstance(network_interfaces, dict):
                network_interfaces = [network_interfaces]
            if network_interfaces and isinstance(network_interfaces[0], dict):
                vm_data['network'] = network_interfaces[0].get('network_id', '')

            # Conversion de la mémoire en Go
            try:
                memory_mb = int(attrs.get('memory', 0))
                vm_data['memory'] = memory_mb // 1024
            except (ValueError, TypeError):
                vm_data['memory'] = ''

            # Gestion du template
            clone = attrs.get('clone', {})
            if isinstance(clone, dict):
                vm_data['vm_template'] = clone.get('template_uuid', '')

            # Gestion des adresses IP
            ip_addresses = attrs.get('guest_ip_addresses', [])
            if isinstance(ip_addresses, list) and ip_addresses:
                vm_data['vm_dns'] = ip_addresses[0]

            # Association des tags
            if 'tags' in attrs:
                for tag_id in attrs['tags']:
                    if tag_id in tags:
                        tag = tags[tag_id]
                        category = tag['category']
                        name = tag['name']

                        # Appliquer le mapping des tags
                        if category in tag_mapping:
                            vm_data[tag_mapping[category]] = name

                        # Cas spécial pour env_tag qui est une copie de env
                        if category == 'env':
                            vm_data['env_tag'] = name

            vms.append(vm_data)

    return vms

def build_dataframe(state_path: Path, csv_header: List[str]) -> pd.DataFrame:
    """Construit un DataFrame à partir du state Terraform."""
    with open(state_path, 'r', encoding='utf-8') as f:
        state = json.load(f)

    tags = extract_tags(state)
    vms = extract_vms_with_tags(state, tags)

    if not vms:
        return pd.DataFrame(columns=csv_header)

    df = pd.DataFrame(vms)

    # S'assurer que toutes les colonnes du header sont présentes
    for col in csv_header:
        if col not in df.columns:
            df[col] = ''

    # Réorganiser selon l'ordre du header
    df = df[csv_header]

    return df

@click.command()
@click.option('--csv-header', type=click.Path(exists=True, dir_okay=False, path_type=Path),
              required=True, help='Fichier CSV dont on veut conserver l\'en-tête')
@click.option('--terraform-state', type=click.Path(exists=True, dir_okay=False, path_type=Path),
              required=True, help='Fichier de state Terraform au format JSON')
@click.option('--output', type=click.Path(dir_okay=False, path_type=Path),
              default=Path('vsphere_vms.csv'), help='Fichier CSV de sortie')
@click.option('--sep', default=';', help='Séparateur CSV')
def main(csv_header: Path, terraform_state: Path, output: Path, sep: str):
    """Génère un CSV des VMs VSphere à partir d'un state Terraform."""
    try:
        click.echo("Chargement de l'en-tête du CSV...")
        header = load_csv_header(csv_header, sep)

        click.echo("Traitement du state Terraform...")
        df = build_dataframe(terraform_state, header)

        click.echo(f"Écriture du fichier de sortie {output}...")
        df.to_csv(output, sep=sep, index=False, encoding='utf-8')

        click.echo(f"✅ Fichier généré avec succès: {output}")
        click.echo(f"Nombre de VMs traitées: {len(df)}")
        click.echo(f"Colonnes incluses: {', '.join(header)}")

    except json.JSONDecodeError:
        click.echo("❌ Erreur: Le fichier de state Terraform n'est pas un JSON valide", err=True)
        raise click.Abort()
    except Exception as e:
        click.echo(f"❌ Erreur: {str(e)}", err=True)
        raise click.Abort()

if __name__ == "__main__":
    main()
