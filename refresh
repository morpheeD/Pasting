import pandas as pd
import json
from pathlib import Path
import click
from typing import List, Dict, Any

def load_csv(path: Path, sep: str = ";") -> pd.DataFrame:
    """Charge un fichier CSV en DataFrame."""
    return pd.read_csv(path, sep=sep, dtype=str)

def load_json(path: Path) -> pd.DataFrame:
    """Charge un fichier JSON en DataFrame."""
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
    return pd.DataFrame(data).astype(str)

def sync(
    df_csv: pd.DataFrame,
    df_json: pd.DataFrame,
    keys: List[str]
) -> pd.DataFrame:
    """
    Synchronise les données entre le CSV et le JSON.
    Met à jour les valeurs du CSV avec celles du JSON quand elles diffèrent.
    Retourne le DataFrame corrigé et un rapport des modifications.
    """
    # Colonnes à comparer (toutes sauf les clés)
    compare_cols = [c for c in df_csv.columns if c not in keys]

    # Fusion des données
    merged = df_csv.merge(
        df_json[keys + compare_cols],
        on=keys,
        how="left",
        suffixes=("", "_json")
    )

    # Liste pour stocker les changements
    changes: List[Dict[str, Any]] = []

    # Comparaison et mise à jour
    for col in compare_cols:
        col_json = f"{col}_json"
        # Trouver les lignes où JSON a une valeur différente et non vide
        mask = (merged[col_json].notna()) & (merged[col] != merged[col_json])

        # Collecter les changements
        for idx in merged[mask].index:
            change = {
                **{k: merged.at[idx, k] for k in keys},
                "column": col,
                "old": merged.at[idx, col],
                "new": merged.at[idx, col_json]
            }
            changes.append(change)

        # Mettre à jour les valeurs du CSV avec celles du JSON
        merged[col] = merged[col_json].combine_first(merged[col])
        merged.drop(columns=[col_json], inplace=True)

    # Créer le DataFrame de rapport de manière sûre
    if changes:
        # Créer un DataFrame vide avec les bonnes colonnes
        key_cols = list(keys) if keys else []
        report_cols = key_cols + ["column", "old", "new"]
        df_report = pd.DataFrame(columns=report_cols)

        # Ajouter les changements un par un
        for change in changes:
            df_report = pd.concat([
                df_report,
                pd.DataFrame([change], columns=report_cols)
            ], ignore_index=True)
    else:
        df_report = pd.DataFrame(columns=["Aucune modification détectée"])

    # Conserver l'ordre original des colonnes
    df_corrected = merged[df_csv.columns]

    return df_corrected, df_report

@click.command()
@click.option('--csv', type=click.Path(exists=True, dir_okay=False, path_type=Path), required=True,
              help='Chemin vers le fichier CSV à mettre à jour')
@click.option('--json', type=click.Path(exists=True, dir_okay=False, path_type=Path), required=True,
              help='Chemin vers le fichier JSON contenant les mises à jour')
@click.option('--keys', multiple=True, default=['vm_name'],
              help='Colonnes clés pour la synchronisation (par défaut: vm_name)')
@click.option('--out', type=click.Path(dir_okay=False, path_type=Path), default=Path('corrected.csv'),
              help='Fichier CSV de sortie corrigé (défaut: corrected.csv)')
@click.option('--report', type=click.Path(dir_okay=False, path_type=Path), default=Path('changes_report.csv'),
              help='Fichier CSV de rapport des modifications (défaut: changes_report.csv)')
def main(csv: Path, json: Path, keys: List[str], out: Path, report: Path):
    """Synchronise un fichier CSV avec les données d'un fichier JSON."""
    try:
        click.echo("Chargement des fichiers...")
        df_csv = load_csv(csv)
        df_json = load_json(json)

        click.echo("Synchronisation en cours...")
        df_corr, df_rep = sync(df_csv, df_json, list(keys))

        click.echo("Sauvegarde des résultats...")
        df_corr.to_csv(out, sep=";", index=False, encoding="utf-8")
        df_rep.to_csv(report, index=False, encoding="utf-8")

        click.echo(f"✅ Fichier corrigé enregistré: {out}")
        click.echo(f"✅ Rapport des modifications enregistré: {report}")
    except Exception as e:
        click.echo(f"❌ Erreur: {str(e)}", err=True)
        raise click.Abort()

if __name__ == "__main__":
    main()
