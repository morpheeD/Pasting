import click
import pandas as pd
import re
from packaging import version
from pathlib import Path

def extract_template_version(template):
    """Extrait la version après 'V-' dans un nom de template"""
    if not isinstance(template, str):
        return None
    match = re.search(r'V-([^-]*)$', template.strip())
    return match.group(1) if match else None

def validate_template_row(row, vmaas_version):
    """Valide une ligne du DataFrame selon les règles de version"""
    template = row.get('vm_template', '').strip()
    vm_name = row.get('vm_name', 'N/A')

    if not template:
        return False, f"Template vide pour la VM '{vm_name}'"

    if version.parse(vmaas_version) >= version.parse("2.0.0"):
        template_version = extract_template_version(template)
        if template_version is None:
            return False, f"Format invalide pour '{template}' (doit contenir 'V-' suivi d'une version)"

        if template_version != "ISIOPERATION":
            try:
                if version.parse(template_version) < version.parse("2.0"):
                    return False, f"Version '{template_version}' < 2.0 pour '{template}'"
            except version.InvalidVersion:
                return False, f"Version invalide '{template_version}' dans '{template}'"

    return True, None

@click.command()
@click.option('--csv-file', type=click.Path(exists=True, dir_okay=False),
              required=True, help='Chemin vers le fichier CSV')
@click.option('--vmaas-version', required=True,
              help='Version de vMaas (ex: 2.0.0)')
@click.option('--chunk-size', default=1000, type=int,
              help='Taille des chunks pour le traitement (défaut: 1000)')
def validate_csv(csv_file, vmaas_version, chunk_size):
    """Valide le fichier CSV selon les règles de vMaas"""
    try:
        # Vérification du fichier
        file_path = Path(csv_file)
        if not file_path.suffix.lower() == '.csv':
            raise ValueError("Le fichier doit être un CSV")

        # Lecture par chunks pour les gros fichiers
        chunks = pd.read_csv(
            file_path,
            delimiter=';',
            chunksize=chunk_size,
            dtype=str,  # Tout lire comme string pour éviter les conversions automatiques
            encoding='utf-8-sig'
        )

        errors = []
        total_rows = 0

        for i, chunk in enumerate(chunks):
            # Vérification des colonnes requises
            if 'vm_template' not in chunk.columns:
                raise ValueError("Colonne 'vm_template' manquante")

            # Validation des lignes
            for _, row in chunk.iterrows():
                total_rows += 1
                is_valid, error_msg = validate_template_row(row, vmaas_version)
                if not is_valid:
                    errors.append(f"Ligne {total_rows} (VM: {row.get('vm_name', 'N/A')}): {error_msg}")

        # Affichage des résultats
        if errors:
            click.echo(f"\n❌ {len(errors)} erreurs trouvées sur {total_rows} lignes:")
            for error in errors[:20]:  # Affiche max 20 erreurs pour ne pas surcharger
                click.echo(f"- {error}")
            if len(errors) > 20:
                click.echo(f"... et {len(errors)-20} autres erreurs")
            exit(1)
        else:
            click.echo(f"\n✅ Validation réussie: {total_rows} lignes valides")

    except Exception as e:
        click.echo(f"\n⚠️  Erreur: {str(e)}", err=True)
        exit(1)

if __name__ == '__main__':
    validate_csv()
